<h1><p align="center">Route256-2023 Middle C#</p></h1>
<h1><p align="center">Sandbox</p></h1>

<details>
<summary>B.Сумма к оплате</summary>
  
<h2><p align="center"> B.Сумма к оплате (10 баллов) </p></h2>
<p align="center"> ограничение по времени на тест: 1 секунда</p>
<p align="center"> ограничение по памяти на тест: 256 мегабайт</p>
<p align="center"> ввод: стандартный ввод</p>
<p align="center"> вывод: стандартный вывод</p>


В магазине акция: «купи три одинаковых товара и заплати только за два». Конечно, каждый купленный товар может участвовать лишь в одной акции. Акцию можно использовать многократно.
Например, если будут куплены 7 товаров одного вида по цене 2 за штуку и 5 товаров другого вида по цене 3 за штуку, то вместо 7⋅2+5⋅3 надо будет оплатить 5⋅2+4⋅3=22.
Считая, что одинаковые цены имеют только одинаковые товары, найдите сумму к оплате.
Неполные решения этой задачи (например, недостаточно эффективные) могут быть оценены частичным баллом.
  
### Входные данные
В первой строке записано целое число t (1≤t≤104) — количество наборов входных данных.

Далее записаны наборы входных данных. Каждый начинается строкой, которая содержит n (1≤n≤2⋅105) — количество купленных товаров. Следующая строка содержит их цены p1,p2,…,pn (1≤pi≤104). Если цены двух товаров одинаковые, то надо считать, что это один и тот товар.

Гарантируется, что сумма значений n по всем тестам не превосходит 2⋅105.

### Выходные данные
Выведите t целых чисел — суммы к оплате для каждого из наборов входных данных.
### Пример
**Входные данные**
```
6
12
2 2 2 2 2 2 2 3 3 3 3 3
12
2 3 2 3 2 2 3 2 3 2 2 3
1
10000
9
1 2 3 1 2 3 1 2 3
6
10000 10000 10000 10000 10000 10000
6
300 100 200 300 200 300
```
**Выходные данные**
```
22
22
10000
12
40000
1100 
```  
</details>

<details>
<summary>C. Парное программирование (10 баллов)</summary>
  
<h2><p align="center">C. Парное программирование (10 баллов)</p></h2>
<p align="center"> ограничение по времени на тест: 1 секунда</p>
<p align="center"> ограничение по памяти на тест: 512 мегабайт</p>
<p align="center"> ввод: стандартный ввод</p>
<p align="center"> вывод: стандартный вывод</p>

  В компании работает n разработчиков, где n — четное число. Сумасшедший менеджер решил разбить всех разработчиков на команды по два человека.

Для этого он составил список всех разработчиков и назначил каждому из них номер по списку (от 1 до n) и значение ai — уровень мастерства i-го в списке разработчика.

Очередную команду он составляет следующим образом:

  1. первый разработчик в команде тот, кто идет первым в списке;
  2. ему в пару подбирается такой, что разница их уровней минимальна (то есть минимально значение |ai−aj|, где |x| — это модуль числа x); если таких кандидатов несколько, то выбирается из них тот, кто находится раньше в списке;
  3. эти два разработчика образуют команду и удаляются из списка.
  
Например, если массив a равен [2,1,3,1,1,4], то формирование команд будет происходить следующим образом:

  1. назначим разработчикам номера [1,2,3,4,5,6] в соответствии с их положением в списке, первый среди них имеет номер 1, его уровень мастерства a1=2, подходящими (с минимальной абсолютной разностью) являются разработчики с номерами 2,3,4,5, первый среди них 2, таким образом первая команда — это разработчики с номерами 1 и 2;
  2. оставшиеся разработчики теперь имеют номера [3,4,5,6], первый среди них 3, его уровень a3=3, разработчик с минимальной абсолютной разностью только один (номер 6), таким образом команда — разработчики с номерами 3 и 6;
  3. оставшиеся разработчики имеют номера [4,5], первый среди них 4, его уровень a4=1, остался только разработчик с номером 5, таким образом третья команда — разработчики с номерами 4 и 5.
  
Ваша задача — помочь сумасшедшему менеджеру промоделировать процесс разбиения на команды. Обратите внимание, что команды должны быть выведены в порядке, описанном выше в условии.
  
### Входные данные
  
Первая строка содержит одно целое число t (1≤t≤50) — количество наборов входных данных.

Первая строка каждого набора содержит одно целое число n (2≤n≤50; n четное) — количество разработчиков.

Вторая строка содержит n целых чисел a1,a2,…,an (1≤ai≤100), где ai — уровень мастерства i-го разработчика.

### Выходные данные
  
Для каждого набора входных данных выведите n2 строк, i-я строка должна содержать пару чисел — номер первого и второго разработчика в i-й команде в порядке, описанном в условии.

Выводите пустую строку между выводами для наборов входных данных. 
  
### Пример
**Входные данные**
```
3
6
2 1 3 1 1 4
2
5 5
8
1 4 2 5 4 2 6 3
```
**Выходные данные**
```
1 2
3 6
4 5

1 2

1 3
2 5
4 7
6 8
```  
</details>

<details>
<summary>D. Электронная таблица (10 баллов)</summary>
  
<h2><p align="center">D. Электронная таблица (10 баллов)</p></h2>
<p align="center"> ограничение по времени на тест: 1 секунда</p>
<p align="center"> ограничение по памяти на тест: 256 мегабайт</p>
<p align="center"> ввод: стандартный ввод</p>
<p align="center"> вывод: стандартный вывод</p>

Вам необходимо написать часть функциональности обработки сортировок в электронных таблицах.

Задана прямоугольная таблица n×m (n строк по m столбцов) из целых чисел.

Если кликнуть по заголовку i-го столбца, то строки таблицы пересортируются таким образом, что в этом столбце значения будут идти по неубыванию (то есть возрастанию или равенству). При этом, если у двух строк одинаковое значение в этом столбце, то относительный порядок строк не изменится.

Рассмотрим пример.
  
 ![image](https://user-images.githubusercontent.com/61276672/217293284-563f2e30-6a6e-4aaf-b310-020084ce09db.png)
В этом примере сначала клик был совершен по второму столбцу, затем по первому и, наконец, по третьему.

Заметим, что если кликнуть подряд два раза в один столбец, то после второго клика таблица не изменится (в момент второго клика она уже отсортирована по этому столбцу).

Обработайте последовательность кликов и выведите состояние таблицы после всех кликов.

Неполные решения этой задачи (например, недостаточно эффективные) могут быть оценены частичным баллом.
  
### Входные данные
В первой строке записано целое число t (1≤t≤100) — количество наборов входных данных в файле. Далее следуют описания наборов, перед каждым из них записана пустая строка.

В первой строке набора записаны два целых числа n и m (1≤n,m≤30) — количество строк и столбцов в таблице.

Далее следуют n строк по m целых чисел в каждой — начальное состояние таблицы. Все элементы таблицы от 1 до 100.

Затем входные данные содержат строку с один целым числом k (1≤k≤30) — количество кликов.

Следующая строка содержит k целых чисел c1,c2,…,ck (1≤ci≤m) — номера столбцов, по которым были осуществлены клики. Клики даны в порядке их совершения.
### Выходные данные
Для каждого набора входных данных выведите n строк по m чисел в каждой — итоговое состояние таблицы. После каждого набора выходных данных выводите дополнительный перевод строки.
### Пример
**Входные данные**
```
3

4 3
3 4 1
2 2 5
2 4 2
2 2 1
3
2 1 3

3 1
100
9
10
2
1 1

3 3
2 11 72
99 11 13
2 8 13
5
2 3 2 1 2
```
**Выходные данные**
```
2 2 1
3 4 1
2 4 2
2 2 5

9
10
100

2 8 13
2 11 72
99 11 13
```  
</details>

<details>
<summary>E. Отчет (15 баллов)</summary>
  
<h2><p align="center">E. Отчет (15 баллов)</p></h2>
<p align="center"> ограничение по времени на тест: 2 секунды</p>
<p align="center"> ограничение по памяти на тест: 512 мегабайт</p>
<p align="center"> ввод: стандартный ввод</p>
<p align="center"> вывод: стандартный вывод</p>

Директор IT-корпорации оценивает эффективность работы сотрудников по различным показателям и критериям. Один из этих критериев сформулирован следующим образом: приступив к некоторому заданию, сотрудник должен завершить его, не переключаясь на другие задания.

Чтобы проверить сотрудников на соответствие этому критерию, директор потребовал от каждого сотрудника отчет о том, какие задания он выполнял в последние n дней. Отчет — это последовательность из n целых чисел a1,a2,…,an, где ai — идентификатор задания, которое сотрудник выполнял в i-й день.

Вам необходимо написать программу, проверяющую, соответствует ли сотрудник критерию по его отчету. Сотрудник соответствует этому критерию, если не существует такого задания x, которое выполнялось с перерывом (т. е. в некоторый день i сотрудник выполнял задание x, в дни с i+1 по j−1 он занимался другими заданиями, а в день j сотрудник продолжил выполнение задания x, при этом j>i+1). Иными словами, каждое задание, которое выполнял сотрудник, должно занимать один непрерывный отрезок дней.

Неполные решения этой задачи (например, недостаточно эффективные) могут быть оценены частичным баллом.
  
### Входные данные
В первой строке задано одно целое число t (1≤t≤10) — количество наборов входных данных.

Каждый набор входных данных состоит из двух строк. В первой строке задано одно целое число n (3≤n≤50000). Во второй строке заданы n целых чисел a1,a2,…,an (1≤ai≤n) — отчет сотрудника.
### Выходные данные
Для каждого набора входных данных выведите ответ на отдельной строке. Если отчет соответствует критерию, выведите YES, иначе выведите NO.
### Пример
**Входные данные**
```
5
5
1 2 3 4 5
4
1 2 3 1
8
2 3 4 8 5 5 5 5
5
1 1 3 2 2
5
1 1 2 3 2
```
**Выходные данные**
```
YES
NO
YES
YES
NO
```  
</details>

<details>
<summary>F. Отрезки времени (20 баллов)</summary>
  
<h2><p align="center">F. Отрезки времени (20 баллов)</p></h2>
<p align="center"> ограничение по времени на тест: 2 секунды</p>
<p align="center"> ограничение по памяти на тест: 512 мегабайт</p>
<p align="center"> ввод: стандартный ввод</p>
<p align="center"> вывод: стандартный вывод</p>
  
Вам задан набор отрезков времени. Каждый отрезок задан в формате HH:MM:SS-HH:MM:SS, то есть сначала заданы часы, минуты и секунды левой границы отрезка, а затем часы, минуты и секунды правой границы.

Вам необходимо выполнить валидацию заданного набора отрезков времени. Иными словами, вам нужно проверить следующие условия:

часы, минуты и секунды заданы корректно (то есть часы находятся в промежутке от 0 до 23, а минуты и секунды — в промежутке от 0 до 59);
левая граница отрезка находится не позже его правой границы (но границы могут быть равны);
никакая пара отрезков не пересекается (даже в граничных моментах времени).
Вам необходимо вывести YES, если заданный набор отрезков времени проходит валидацию, и NO в противном случае.

Вам необходимо ответить на t независимых наборов тестовых данных.

Неполные решения этой задачи (например, недостаточно эффективные) могут быть оценены частичным баллом.
  
### Входные данные
Первая строка входных данных содержит одно целое число t (1≤t≤10) — количество наборов тестовых данных. Затем следуют t наборов.

Первая строка набора содержит одно целое число n (1≤n≤2⋅104) — количество отрезков времени. В следующих n строках следуют описания отрезков.

Описание отрезка времени задано в формате HH:MM:SS-HH:MM:SS, где HH, MM и SS — последовательности из двух цифр. Заметьте, что никаких пробелов в описании формата нет. Также ни в одном описании нет пробелов в начале и конце строки.
  
### Выходные данные
Для каждого набора тестовых данных выведите ответ — YES, если заданный набор отрезков времени проходит валидацию, и NO в противном случае. Ответы выводите в порядке следования наборов во входных данных.
  
### Пример
**Входные данные**
```
6
1
02:46:00-03:14:59
2
23:59:59-23:59:59
00:00:00-23:59:58
2
23:59:58-23:59:59
00:00:00-23:59:58
2
23:59:59-23:59:58
00:00:00-23:59:57
6
17:53:39-20:20:02
10:39:17-11:00:52
08:42:47-09:02:14
09:44:26-10:21:41
00:46:17-02:07:19
22:42:50-23:17:46
1
24:00:00-23:59:59
```
**Выходные данные**
```
YES
YES
NO
NO
YES
NO
```  
</details>
<details>
  
<summary>G. Возможные друзья (20 баллов)</summary>
  
<h2><p align="center">G. Возможные друзья (20 баллов)</p></h2>
<p align="center"> ограничение по времени на тест: 3 секунды</p>
<p align="center"> ограничение по памяти на тест: 512 мегабайт</p>
<p align="center"> ввод: стандартный ввод</p>
<p align="center"> вывод: стандартный вывод</p>

Во многих социальных сетях у пользователей есть возможность указать других пользователей как своих друзей. Помимо этого, часто существует система рекомендации друзей, которая показывает пользователям людей, с которыми они знакомы косвенно (через кого-то из своих друзей), и предлагает добавить этих людей в список друзей. Вам предстоит разработать систему рекомендации друзей.

В интересующей нас социальной сети n пользователей, каждому из которых присвоен уникальный id от 1 до n. У каждого пользователя этой сети не более 5 друзей. Очевидно, ни один пользователь не является другом самому себе, и если пользователь x в списке друзей у пользователя y, то и пользователь y входит в список друзей пользователя x.

Опишем, как должен формироваться список возможных друзей для каждого пользователя. Для пользователя x в список должны входить такие пользователи y, что:

* y не является другом x и не совпадает с x;
* у пользователя y и у пользователя x есть хотя бы один общий друг;
* не существует такого пользователя y′, который удовлетворяет первым двум ограничениям, и у которого строго больше общих друзей с x, чем у y с x.
  
Иными словами, в список возможных друзей пользователя x входят все такие пользователи, не являющиеся его друзьями, для которых количество общих друзей с x максимально. Обратите внимание, что список возможных друзей может быть пустым.

Вы должны написать программу, которая по заданной структуре социальной сети формирует списки возможных друзей для всех пользователей сети.

Неполные решения этой задачи (например, недостаточно эффективные) могут быть оценены частичным баллом.
  
### Входные данные
  
  В первой строке заданы два целых числа n и m (2≤n≤50000; 0≤m≤min(n(n−1)/2,5n/2)) — количество пользователей и количество пар друзей, соответственно.

Далее следуют m строк, в каждой из которых заданы два целых числа xi и yi (1≤xi,yi≤n; xi≠yi) — очередная пара друзей в социальной сети. Каждая пара друзей задается не более одного раза; у каждого пользователя не более 5 друзей.

### Выходные данные
  
  Для каждого пользователя от 1 до n выведите в отдельной строке список его возможных друзей в следующем формате:

* если список возможных друзей пуст, выведите одно целое число 0;
* иначе выведите id возможных друзей пользователя в возрастающем порядке.
  
### Пример
**Входные данные**
```
8 6
4 3
3 1
1 2
2 4
2 5
6 8
```
**Выходные данные**
```
4
3
2
1
1 4
0
0
0
```  
  **Примечание**
  Рассмотрим первый пример из условия.

Для начала сформируем списки друзей всех пользователей:

* друзья пользователя 1: [2,3].
* друзья пользователя 2: [1,4,5].
* друзья пользователя 3: [1,4].
* друзья пользователя 4: [2,3].
* друзья пользователя 5: [2].
* друзья пользователя 6: [8].
* друзья пользователя 7: [] (список друзей пуст).
* друзья пользователя 8: [6].
Рассмотрим, как формируются списки возможных друзей для некоторых пользователей.

У пользователя 1 есть два пользователя, которые не являются его друзьями и с которыми у него есть хотя бы один общий друг: это пользователь 4 (общие друзья 2 и 3) и пользователь 5 (общий друг 2). С пользователем 4 общих друзей больше, поэтому в список возможных друзей попадает только он.

У пользователя 5 есть два пользователя, которые не являются его друзьями и с которыми у него есть хотя бы один общий друг: это пользователь 1 (общий друг 2) и пользователь 4 (общий друг 2). Количество общих друзей одинаковое, поэтому оба этих пользователя попадают в список возможных друзей.

У пользователя 7 вообще нет друзей, поэтому ни один пользователь не удовлетворяет требованиям списка возможных друзей.
  
</details>
<details>
<summary>H. Валидация карты (25 баллов)</summary>
  
<h2><p align="center">H. Валидация карты (25 баллов)</p></h2>
<p align="center"> ограничение по времени на тест: 1 секунда</p>
<p align="center"> ограничение по памяти на тест: 512 мегабайт</p>
<p align="center"> ввод: стандартный ввод</p>
<p align="center"> вывод: стандартный вывод</p>

В этой задаче вам необходимо реализовать валидацию корректности карты для стратегической компьютерной игры.

Карта состоит из гексагонов (шестиугольников), каждый из которых принадлежит какому-то региону карты. В файлах игры карта представлена как n строк по m символов в каждой (строки и символы в них нумеруются с единицы). Каждый нечетный символ каждой четной строки и каждый четный символ каждой нечетной строки — точка (символ . с ASCII кодом 46); все остальные символы соответствуют гексагонам и являются заглавными буквами латинского алфавита. Буква указывает на то, какому региону принадлежит гексагон.

Посмотрите на картинку ниже, чтобы понять, как описание карты в файлах игры соответствует карте из шестиугольников.
  ![image](https://user-images.githubusercontent.com/61276672/217297178-def11a78-879c-450b-9248-e047b662e739.png)
<p align="center">Соответствие описания карты в файле (слева) и самой карты (справа). Регионы R, G, V, Y и B окрашены в красный, зеленый, фиолетовый, желтый и синий цвет, соответственно.</p>
  Вы должны проверить, что каждый регион карты является одной связной областью. Иными словами, не должно быть двух гексагонов, принадлежащих одному и тому же региону, которые не соединены другими гексагонами этого же региона.
  ![image](https://user-images.githubusercontent.com/61276672/217297444-49c520cc-f12e-480a-ac71-f97ff3d633a9.png)
<p align="center">Карта слева является корректной. Карта справа не является корректной, так как гексагоны, обозначенные цифрами 1 и 2, принадлежат одному и тому же региону (обозначенному красным цветом), но не соединены другими гексагонами этого региона.</p>
Неполные решения этой задачи (например, недостаточно эффективные) могут быть оценены частичным баллом.
  
### Входные данные
В первой строке задано одно целое число t (1≤t≤100) — количество наборов входных данных.

Первая строка набора входных данных содержит два целых числа n и m (2≤n,m≤20) — количество строк и количество символов в каждой строке в описании карты.

Далее следуют n строк по m символов в каждой — описание карты. Каждый нечетный символ каждой четной строки и каждый четный символ каждой нечетной строки — точка (символ . с ASCII кодом 46); все остальные символы соответствуют гексагонам и являются заглавными буквами латинского алфавита.
### Выходные данные
  На каждый набор входных данных выведите ответ в отдельной строке — YES, если каждый регион карты представляет связную область, или NO, если это не так.
### Пример
**Входные данные**
```
3
3 7
R.R.R.G
.Y.G.G.
B.Y.V.V
4 8
Y.R.B.B.
.R.R.B.V
B.R.B.R.
.B.B.R.R
2 7
G.B.R.G
.G.G.G.
```
**Выходные данные**
```
YES
NO
YES
```  
  **Примечание**
Первые два набора входных данных из примера показаны на второй картинке в условии.
</details>
<details>
<summary>I. Планировщик задач (30 баллов)</summary>
  
<h2><p align="center">I. Планировщик задач (30 баллов)</p></h2>
<p align="center"> ограничение по времени на тест: 3 секунды</p>
<p align="center"> ограничение по памяти на тест: 256 мегабайт</p>
<p align="center"> ввод: стандартный ввод</p>
<p align="center"> вывод: стандартный вывод</p>

Представьте, вы собрали собственный сервер из n разнородных процессоров и теперь решили создать для него простейший планировщик задач.

Ваш сервер состоит из n процессоров. Но так как процессоры разные, то и достигают они одинаковой скорости работы при разном энергопотреблении. А именно, i-й процессор в нагрузке тратит ai энергии за одну секунду.

Вашему серверу в качестве тестовой нагрузки придет m задач. Про каждую задачу вам известны два значения: tj и lj — момент времени, когда задача j придет и время выполнения задачи в секундах.

Для начала вы решили реализовать простейший планировщик, ведущий себя следующим образом: в момент tj прихода задачи, вы выбираете свободный процессор с минимальным энергопотреблением и выполняете данную задачу на выбранном процессоре все заданное время. Если к моменту прихода задачи свободных процессоров нет, то вы просто отбрасываете задачу.

Процессор, на котором запущена задача j будет занят ровно lj секунд, то есть освободится ровно в момент tj+lj и в этот же момент уже может быть назначен для выполнения какой-то другой задачи.

Определите суммарное энергопотребление вашего сервера при обработке m заданных задач (будем считать, что процессоры в простое не потребляют энергию).

Неполные решения этой задачи (например, недостаточно эффективные) могут быть оценены частичным баллом.
  
### Входные данные
В первой строке заданы два целых числа n и m (1≤n,m≤3⋅105) — количество процессоров и задач соответственно.

Во второй строке заданы n целых чисел a1,a2,…,an (1≤ai≤106) — энергопотребление соответствующих процессоров под нагрузкой в секунду. Все энергопотребления различны.

В следующих m строках заданы описания задач: по одному в строке. В j-й строке заданы два целых числа tj и lj (1≤tj≤109; 1≤lj≤106) — момент прихода j-й задачи и время ее выполнения.

Все времена прихода tj различны, и задачи заданы в порядке времени прихода.
### Выходные данные
  Выведите единственное число — суммарное энергопотребление сервера, если потреблением энергии в простое можно пренебречь.
### Пример
**Входные данные**
```
4 7
3 2 6 4
1 3
2 5
3 7
4 10
5 5
6 100
9 2
```
**Выходные данные**
```
105
```  
**Примечание**
Рассмотрим работу планировщика посекундно:

t=1: приходит первая задача, все процессоры свободны. Задача занимает второй процессор на 3 секунды.
t=2: приходит вторая задача. Второй процессор занят, а потому задача занимает первый процессор на 5 секунд.
t=3: приходит третья задача и занимает четвертый процессор на 7 секунд.
t=4: приходит четвертая задача. Второй процессор освободился в данный момент, а потому его и занимает задача на 10 секунд.
t=5: приходит пятая задача и занимает последний свободный на данный момент процессор (третий) на 5 секунд.
t=6: приходит шестая задача. Все процессоры еще заняты, а потому задача отбрасывается.
t=7: освобождается первый процессор.
t=9: приходит седьмая задача и занимает первый процессор на 2 секунды.
t=10: освобождаются третий и четвертый процессоры.
t=11: освобождается первый процессор.
t=14: освобождается второй процессор.
Общее энергопотребление равно 3⋅2 + 5⋅3 + 7⋅4 + 10⋅2 + 5⋅6 + 2⋅3 = 6+15+28+20+30+6 = 105.
</details>

<details>
<summary>J. Рифмы (30 баллов)</summary>
  
<h2><p align="center">J. Рифмы (30 баллов)</p></h2>
<p align="center"> ограничение по времени на тест: 2 секунды</p>
<p align="center"> ограничение по памяти на тест: 512 мегабайт</p>
<p align="center"> ввод: стандартный ввод</p>
<p align="center"> вывод: стандартный вывод</p>

Вы разрабатываете программу автоматической генерации стихотворений. Один из модулей этой программы должен подбирать рифмы к словам из некоторого словаря.

Словарь содержит n различных слов. Словами будем называть последовательности из 1—10 строчных букв латинского алфавита.

Зарифмованность двух слов — это длина их наибольшего общего суффикса (суффиксом будем называть какое-то количество букв в конце слова). Например:

* task и flask имеют зарифмованность 3 (наибольший общий суффикс — ask);
* decide и code имеют зарифмованность 2 (наибольший общий суффикс — de);
* id и void имеют зарифмованность 2 (наибольший общий суффикс — id);
* code и forces имеют зарифмованность 0.
  
Ваша программа должна обработать q запросов следующего вида: дано слово ti (возможно, принадлежащее словарю), необходимо найти слово из словаря, которое не совпадает с ti и имеет максимальную зарифмованность с ti среди всех слов словаря, не совпадающих с ti. Если подходящих слов несколько — выведите любое из них.

Неполные решения этой задачи (например, недостаточно эффективные) могут быть оценены частичным баллом.
  
### Входные данные
Первая строка содержит одно целое число n (2≤n≤50000) — размер словаря.

Далее следуют n строк, i-я строка содержит одну строку si (1≤|si|≤10) — i-е слово из словаря. В словаре все слова различны.

Следующая строка содержит одно целое число q (1≤q≤50000) — количество запросов.

Далее следуют q строк, i-я строка содержит одну строку ti (1≤|ti|≤10) — i-й запрос.

Каждая строка si и каждая строка ti состоит только из строчных букв латинского алфавита.
### Выходные данные
  
Для каждого запроса выведите одну строку — слово из словаря, которое не совпадает с заданным в запросе и имеет с ним максимальную зарифмованность (если таких несколько — выведите любое).
  
### Пример
**Входные данные**
```
3
task
decide
id
6
flask
code
void
forces
id
ask
```
**Выходные данные**
```
task
decide
id
task
decide
task
```  
</details>
<details>
<summary>K. Пользователи и заказы (SQL, 10 баллов)</summary>
  
<h2><p align="center">K. Пользователи и заказы (SQL, 10 баллов)</p></h2>
<p align="center"> ограничение по времени на тест: 15 секунд</p>
<p align="center"> ограничение по памяти на тест: 1024 мегабайта</p>
<p align="center"> ввод: стандартный ввод</p>
<p align="center"> вывод: стандартный вывод</p>

Это необычная задача — вам надо написать SQL-запрос. В качестве решения вы должны отослать один запрос к базе данных, который возвращает требуемые данные. При проверке вашего решения используется PostgreSQL 15.1. В качестве входных данных вам предоставляется дамп состояния базы данных. Обратите внимание, что время работы вашего решения на тесте включает восстановление состояния базы данных из дампа, но это время значительно меньше ограничения по времени. Вы можете использовать сервис http://sqlfiddle.com/ как инструмент для запуска запросов.

Напишите запрос к базе данных, который возвращает всех пользователей, сделавших хотя бы один заказ. Выведите всех таких пользователей, отсортировав их по имени (при равенстве по id).

Схема базы данных содержит две таблицы: users и orders, которые связаны отношением «один ко многим». Изучите входные данные примера, чтобы подробно ознакомиться со схемой базы данных. Диаграмма ниже иллюстрирует схему базы данных.
  ![image](https://user-images.githubusercontent.com/61276672/217299021-17e140e6-888e-47da-ad69-1ef3839d7eb3.png)

  
### Входные данные
Входными данными в этой задаче является дамп базы данных. Вам он может быть полезен для ознакомления с состоянием базы данных для конкретного теста. В качестве решения вы должны отправить один SQL-запрос.
### Выходные данные
  Ваш SQL-запрос должен вывести всех пользователей в порядке неубывания их имён (по возрастанию id при равенстве имён). Используйте collation по умолчанию.
### Пример
**Входные данные**
```
create table users
(
    id   bigint primary key,
    name varchar not null
);

insert into users
values (1, 'john'),
       (2, 'Liza'),
       (7, 'Odin'),
       (11, 'donatello'),
       (17, 'spider-man'),
       (19, 'Elen'),
       (20, 'Liza');

create table orders
(
    id         bigint primary key,
    user_id    bigint  not null,
    product    varchar not null,
    constraint fk_orders_user_id foreign key (user_id) references users (id)
);

insert into orders
values (101, 17, 'pizza'),
       (107, 2, 'toothpaste'),
       (108, 19, 'candies'),
       (109, 20, 'pizza'),
       (200, 17, 'shampoo'),
       (205, 2, 'pizza'),
       (210, 19, 'toothpaste'),
       (220, 19, 'pizza'),
       (221, 11, 'shampoo'),
       (222, 19, 'pizza');
```
**Выходные данные**
```
 id |    name
----+------------
 11 | donatello
 19 | Elen
  2 | Liza
 20 | Liza
 17 | spider-man
(5 rows)
```  
</details>
<h1><p align="center">Contest</p></h1>

<details>
<summary>B. Морской бой (10 баллов)</summary>
  
<h2><p align="center">B. Морской бой (10 баллов)</p></h2>
<p align="center"> ограничение по времени на тест: 2 секунды</p>
<p align="center"> ограничение по памяти на тест: 512 мегабайт</p>
<p align="center"> ввод: стандартный ввод</p>
<p align="center"> вывод: стандартный вывод</p>

  Это наиболее простая задача Контеста. Надеемся, что вы познакомились с тестирующей системой Codeforces, приняв участие в Песочнице. В любом случае напоминаем вам несколько моментов.

Правильные решения задач должны проходить все заранее заготовленные тесты жюри и укладываться в ограничения по времени/памяти на каждом тесте. В некоторых задачах допустимы частичные решения (это написано в условии).

Ниже перечислены технические требования к решениям:

* решение располагается в одном файле исходного кода;
* решение читает входные данные со стандартного ввода (экрана);
* решение пишет выходные данные на стандартный вывод (экран);
* решение не взаимодействует как-либо с другими ресурсами компьютера (сеть, жесткий диск, процессы и прочее);
* решение использует только стандартную библиотеку языка;
* решение располагается в пакете по-умолчанию (или его аналоге для вашего языка), имеют стандартную точку входа для консольных программ;
* гарантируется, что во всех тестах выполняются все ограничения, что содержатся в условии задачи — как-либо проверять входные данные на корректность не надо, все тесты строго соответствуют описанному в задаче формату;
* выводи ответ в точности в том формате, как написано в условии задачи (не надо выводить «поясняющих» комментариев типа введите число или ответ равен);
* решения можно отправлять сколько угодно раз (пожалуйста, только без абьюза системы).
  
Для вашего удобства большинство тестов, на которых будут тестироваться ваши решения, являются открытыми. В каждой задаче можно скачать архив тестов (смотрите сайдбар справа, раздел «Материалы соревнования»).

Обратите внимание на SQL-задачу. Не забудьте попробовать свои силы в её решении.

Перейдём к задаче.

Вы участвуете в разработке подсистемы проверки поля для игры «Морской бой». Вам требуется написать проверку корректности количества кораблей на поле, учитывая их размеры. Напомним, что на поле должны быть:

* четыре однопалубных корабля,
* три двухпалубных корабля,
* два трёхпалубных корабля,
* один четырёхпалубный корабль.
  
Вам заданы 10 целых чисел от 1 до 4. Проверьте, что заданные размеры соответствуют требованиям выше.
  
### Входные данные
  
В первой строке записано целое число t (1≤t≤1000) — количество наборов входных данных в тесте.

Наборы входных данных в тесте независимы. Друг на друга они никак не влияют.

Каждый набор входных данных состоит из одной строки, которая содержит 10 целых чисел a1,a2,…,a10 (1≤ai≤4) — размеры кораблей на поле в произвольном порядке.

Обратите внимание, что уже гарантируется, что кораблей на поле ровно 10 и их размеры от 1 до 4, включительно. Вам необходимо проверить, что количество кораблей каждого типа соответствует правилам игры.
  
### Выходные данные
  
  Для каждого набора входных данных в отдельной строке выведите:

* YES, если заданные размеры кораблей на поле соответствуют правилам игры;
* NO в противном случае.
  
Вы можете выводить YES и NO в любом регистре (например, строки yEs, yes, Yes и YES будут распознаны как положительный ответ).
  
### Пример
**Входные данные**
```
5
2 1 3 1 2 3 1 1 4 2
1 1 1 2 2 2 3 3 3 4
1 1 1 1 2 2 2 3 3 4
4 3 3 2 2 2 1 1 1 1
4 4 4 4 4 4 4 4 4 4
```
**Выходные данные**
```
YES
NO
YES
YES
NO
```  
</details>
<details>
<summary>C. Автомобильные номера (15 баллов)</summary>
  
<h2><p align="center">C. Автомобильные номера (15 баллов)</p></h2>
<p align="center"> ограничение по времени на тест: 2 секунды</p>
<p align="center"> ограничение по памяти на тест: 512 мегабайт</p>
<p align="center"> ввод: стандартный ввод</p>
<p align="center"> вывод: стандартный вывод</p>

  В Берляндии автомобильные номера состоят из цифр и прописных букв латинского алфавита. Они бывают двух видов:

* либо автомобильный номер имеет вид буква-цифра-цифра-буква-буква (примеры корректных номеров первого вида: R48FA, O00OO, A99OK);
* либо автомобильный номер имеет вид буква-цифра-буква-буква (примеры корректных номеров второго вида: T7RR, A9PQ, O0OO).
  
Таким образом, каждый автомобильный номер является строкой либо первого, либо второго вида.

Вам задана строка из цифр и прописных букв латинского алфавита. Можно ли разделить её пробелами на последовательность корректных автомобильных номеров? Иными словами, проверьте, что заданная строка может быть образована как последовательность корректных автомобильных номеров, которые записаны подряд без пробелов. В случае положительного ответа выведите любое такое разбиение.
  
### Входные данные
В первой строке записано целое число t (1≤t≤1000) — количество наборов входных данных в тесте.

Наборы входных данных в тесте независимы. Друг на друга они никак не влияют.

Каждый набор входных данных — непустая строка s, которая состоит из цифр и прописных букв латинского алфавита. Длина строки — от 1 до 50 символов.
### Выходные данные
Выведите n строк: очередная строка должна содержать ответ для соответствующего набора входных данных.

Если ответ отрицательный — то есть заданную строку s невозможно представить как последовательность номеров автомобилей — строка в выводе должна содержать единственный символ '-' (минус, ASCII-код 45).

В случае положительного ответа выведите любое разбиение заданной строки s на последовательность корректных номеров. Каждый номер должен соответствовать одному из двух видов (см. условие). Номера разделяйте пробелами. Вы можете выводить произвольное количество пробелов и даже лишние пробелы после последнего номера.
### Пример
**Входные данные**
```
6
R48FAO00OOO0OOA99OKA99OK
R48FAO00OOO0OOA99OKA99O
A9PQ
A9PQA
A99AAA99AAA99AAA99AA
AP9QA
```
**Выходные данные**
```
 R48FA O00OO O0OO A99OK A99OK
-
A9PQ
-
A99AA A99AA A99AA A99AA
-
```  
</details>
<details>
<summary>D. Результаты соревнования (20 баллов)</summary>
  
<h2><p align="center">D. Результаты соревнования (20 баллов)</p></h2>
<p align="center"> ограничение по времени на тест: 3 секунды</p>
<p align="center"> ограничение по памяти на тест: 512 мегабайт</p>
<p align="center"> ввод: стандартный ввод</p>
<p align="center"> вывод: стандартный вывод</p>

  В соревновании по бегу приняли участие n спортсменов: i-й из них пробежал дистанцию за ti секунд. Жюри хочет назначить места участникам по следующим правилам:

* места пронумерованы от 1 и далее (лучшее место — первое);
* если у двух спортсменов результаты одинаковые или отличаются на одну секунду, то они делят место (в этом случае считаем, что они делят лучшее из поделенных мест);
* участники делят место только в результате применения предыдущего правила (возможно, несколько раз);
* если k участников делят место p, то места следующих за ними участников нумеруются начиная с k+p.
  
Рассмотрите следующие примеры, чтобы понять принцип назначения мест:

* допустим, n=4 и t=[20,10,20,30], тогда места имеют вид [2,1,2,4] (второй спортсмен прибежал первым — у него первое место, первый и третий поделили второе место, четвёртый занял последнее четвёртое место);
* допустим, n=3 и t=[5,7,6], тогда места имеют вид [1,1,1] (так как t1=5 и t3=6 отличаются на 1, то первый и третий спортсмены должны занять одинаковое место, аналогично со вторым и третьим спортсменами, следовательно, все трое делят первое место);
* допустим, n=5 и t=[6,3,4,3,1], тогда места имеют вид [5,2,2,2,1];
* допустим, n=5 и t=[200,10,100,11,200], тогда места имеют вид [4,1,3,1,4].
  
По заданным значениям n и t1,t2,…,tn выведите последовательность мест, занятых спортсменами.

Неполные решения этой задачи (например, недостаточно эффективные) могут быть оценены частичным баллом.
  
### Входные данные
В первой строке записано целое число t (1≤t≤1000) — количество наборов входных данных в тесте.

Наборы входных данных в тесте независимы. Друг на друга они никак не влияют.

Первая строка каждого набора входных данных содержит целое число n (1≤n≤2⋅105) — количество спортсменов.

Вторая строка набора содержит последовательность целых чисел t1,t2,…,tn (1≤ti≤109), где ti — время в секундах, за которое i-й спортсмен пробежал дистанцию.

Сумма значений n по всем наборам входных данных теста не превосходит 2⋅105.
### Выходные данные
  Для каждого набора входных данных выведите n положительных чисел r1,r2,…,rn, где ri — место i-го спортсмена.
### Пример
**Входные данные**
```
6
4
20 10 20 30
3
5 7 6
5
6 3 4 3 1
5
200 10 100 11 200
1
1000000000
11
13 8 12 1 7 10 1 8 10 2 17
```
**Выходные данные**
```
 2 1 2 4 
1 1 1 
5 2 2 2 1 
4 1 3 1 4 
1 
9 4 9 1 4 7 1 4 7 1 11 
```  
</details>
<details>
<summary>E. Товарные знаки (20 баллов)</summary>
  
<h2><p align="center">E. Товарные знаки (20 баллов)</p></h2>
<p align="center"> ограничение по времени на тест: 5 секунд</p>
<p align="center"> ограничение по памяти на тест: 512 мегабайт</p>
<p align="center"> ввод: стандартный ввод</p>
<p align="center"> вывод: стандартный вывод</p>

  В Торгово-промышленную палату (ТПП) Берляндии были поданы n заявок на регистрацию товарных знаков. Каждая заявка — это непустая строка из букв латинского алфавита.

ТПП отклоняет очередную заявку, если ранее был зарегистрирован похожий товарный знак. Если такого не было, то товарный знак регистрируется палатой.

Два товарных знака похожи, если их можно сделать равными с помощью нуля или более таких операций:

* возьмём любой из двух знаков,
* найдём в знаке две или более одинаковые идущие подряд буквы,
* добавим в этот блок одинаковых букв ещё одну такую же букву.
  
Например:

* товарные знаки Booble и Boooble похожи — берём в первом товарном знаке две подряд идущие буквы o и добавляем к ним ещё одну букву o, так получим второй товарный знак Boooble;
* товарные знаки yyyess и yyessss похожи — сначала изменим второй товарный знак: yyessss → yyyessss, потом два раза изменим первый товарный знак: yyyess → yyyesss → yyyessss. Так с помощью последовательности операций получилось сделать оба знака равными yyyessss;
* товарные знаки oooops и oooops похожи — операций производить не надо, знаки уже равны;
* товарные знаки oooooopppss и ooooppssss похожи — например, сначала изменим второй товарный знак ooooppssss → oooooppssss → ooooooppssss → oooooopppssss, затем изменим первый: oooooopppss → oooooopppsss → oooooopppssss.
Обратите внимание, что добавлять букву можно только в блок идущих подряд двух или более одинаковых букв. Строчные и прописные буквы следует различать.

Примеры пар непохожих товарных знаков: a и aa, MMM и mmm, yess и yyes.

Считая, что до обработки n заявок в ТПП не было зарегистрировано других товарных знаков, выведите количество знаков, которые будут в итоге зарегистрированы.

Неполные решения этой задачи (например, недостаточно эффективные) могут быть оценены частичным баллом.
  
### Входные данные
В первой строке входных данных записано целое число t (1≤t≤1000) — количество наборов входных данных.

Наборы входных данных в тесте независимы. Друг на друга они никак не влияют.

В первой строке каждого набора записано целое число n (1≤n≤105) — количество заявок. Далее следуют сами заявки, по одной заявке в строке. Каждая заявка является непустой строкой из букв латинского алфавита.

Гарантируется, что сумма длин заявок по всем наборам входных данных теста не превосходит 106.
  
### Выходные данные
  Выведите t чисел — для каждого набора входных данных выведите суммарное количество товарных знаков, которые будут зарегистрированы палатой. Обратите внимание, что наборы входных данных следует обрабатывать независимо (они не влияют друг на друга).
  
### Пример
**Входные данные**
```
3
8
Booble
yyyess
oooops
oooooopppss
Boooble
yyessss
oooops
ooooppssss
6
a
aa
MMM
mmm
yess
yyes
5
rrrrrrrr
rrrrrr
rrr
rr
r
```
**Выходные данные**
```
4
6
2
```  
</details>
<details>
<summary>F. Печать документа (20 баллов)</summary>
  
<h2><p align="center">F. Печать документа (20 баллов)</p></h2>
<p align="center"> ограничение по времени на тест: 3 секунды</p>
<p align="center"> ограничение по памяти на тест: 512 мегабайт</p>
<p align="center"> ввод: стандартный ввод</p>
<p align="center"> вывод: стандартный вывод</p>

Необходимо напечатать документ из k страниц. Его страницы пронумерованы от 1 до k.

Некоторые его страницы были уже предварительно напечатаны. Известно, что на принтер было отослано одно задание, которое содержало список страниц для печати.

Этот список содержит хотя бы одну страницу, и хотя бы одна страница от 1 до k не попадает в этот список. Список страниц состоит из перечисленных через единичную запятую элементов списка, где каждый элемент — это:

* либо конкретный номер одной страницы (целое число от 1 до k),
* либо диапазон страниц, записанный в формате «l-r», где l — начало диапазона печати, а r — конец диапазона печати (и l и r целые числа, удовлетворяющие неравенству 1≤l≤r≤k).
  
Страница может многократно присутствовать в списке на печать, но будет напечатана лишь единожды.

Иными словами, список страниц имеет формат, аналогичный тому, что используется в «Microsoft Word» или других подобных программах.

Например, если k=8, то допустимые списки страниц:

* 7 (была напечатана лишь страница 7),
* 1,7,1 (были напечатаны страницы 1 и 7),
* 1-5,1,7-7 (были напечатаны страницы 1,2,3,4,5,7).
  
Примеры неправильных диапазонов для k=8 (такие входные данные недопустимы):

* 1-8 (хотя бы одна страница документа должна быть еще не напечатана),
* 1,,3 (две запятые не могут идти подряд),
* 7-9 (девятую страницу нельзя послать на печать),
* 1-5, (каждая запятая должна разделять два элемента, заканчивать список она не может),
* ,1,2,3-5 (каждая запятая должна разделять два элемента, начинать список она не может),
* 3-4-7 (нарушен формат элемента, так нельзя).
  
Выведите кратчайший список страниц в аналогичном формате, который надо дополнительно послать на печать, чтобы в итоге напечатать все страницы от 1 до k, не напечатанные ранее.

Иными словами, найдите такую наиболее короткую строку, которая является корректным списком страниц и содержит те и только те страницы, которые еще не были напечатаны.

Если ответов несколько, то выведите любой из них.
  
### Входные данные
В первой строке входных данных записано целое число t (1≤t≤100) — количество наборов входных данных.

Наборы входных данных в тесте независимы. Друг на друга они никак не влияют.

В первой строке каждого набора записано целое число k (2≤k≤100) — количество страниц в документе.

Вторая строка каждого набора содержит список страниц, которые уже были посланы на печать. Этот список корректен и отформатирован строго по правилам, написанным выше. Он содержит только страницы от 1 до k, содержит хотя бы одну страницу, и хотя бы одна страница от 1 до k в него не входит. Строка не содержит пробелы или какие-либо другие дополнительные символы. Длина этой строки — от 1 до 400, включительно.
  
### Выходные данные
  Выведите t строк — для каждого набора входных данных выведите кратчайшую строку, содержащую корректный список страниц, которые надо допечатать и только их. Если оптимальных ответов несколько, то выведите любой из них.
  
### Пример
**Входные данные**
```
7
8
7
8
1,7,1
8
1-5,1,7-7
10
1-5
10
1,2,3,4,5,6,8,9,10
3
1-2
100
1-2,3-7,10-20,100
```
**Выходные данные**
```
 8,1-6
2-6,8
6,8
6-10
7
3
9,21-99,8
```  
</details>
<details>
<summary>G. Записи ко врачу (25 баллов)</summary>
  
<h2><p align="center">G. Записи ко врачу (25 баллов)</p></h2>
<p align="center"> ограничение по времени на тест: 3 секунды</p>
<p align="center"> ограничение по памяти на тест: 512 мегабайт</p>
<p align="center"> ввод: стандартный ввод</p>
<p align="center"> вывод: стандартный вывод</p>

  Врач за день может принять до n пациентов. Окна времени для приёма пронумерованы от 1 до n в хронологическом порядке.

Ассистент записал m человек, i-го человека на окно wi (1≤wi≤n). Выяснилось, что некоторые пациенты могут быть записаны на одно окно. Может ли ассистент попросить подвинуться некоторых пациентов на одно окно вперёд или назад так, чтобы у врача была возможность принять всех?

Обратите внимание, что для каждого пациента возможны три сценария:

* оставить его запись как есть,
* изменить его запись на одно окно назад (то есть заменить значение wi на wi−1),
* изменить его запись на одно окно вперёд (то есть заменить значение wi на wi+1).
  
Конечно, в двух последних случаях запись должна остаться в окне от 1 до n.

Определите, можно ли исправить записи требуемым образом так, чтобы врач смог принять всех пациентов. В случае положительного ответа выведите любой из способов это сделать.

Обратите внимание, что вам не требуется минимизировать количество перенесённых записей. Достаточно найти любой способ перенести произвольное количество записей требуемым образом, чтобы врач смог принять всех пациентов.

Неполные решения этой задачи (например, недостаточно эффективные) могут быть оценены частичным баллом.
  
### Входные данные
В первой строке входных данных записано целое число t (1≤t≤1000) — количество наборов входных данных.

Наборы входных данных в тесте независимы. Друг на друга они никак не влияют.

В первой строке каждого набора записаны два целых числа n и m (1≤m≤n≤3⋅105), где n — количество окон приёма у врача, а m — количество записанных пациентов.

Во второй строке записано m целых чисел w1,w2,…,wm (1≤wi≤n), где wi — номер окна, на которое записан i-й пациент.

Гарантируется, что сумма значений n по всем наборам входных данных теста не превосходит 3⋅105.
### Выходные данные
Выведите m строк, j-я строка должна содержать ответ на j-й набор входных данных.

Если перенести записи требуемым образом невозможно, выведите x (строчную латинскую букву «икс»).

Иначе выведите строку без пробелов из m символов, где каждый символ — это:

0 (ноль), если запись соответствующего пациента менять не надо,
- (минус), если запись соответствующего пациента надо изменить на одно окно назад,
+ (плюс), если запись соответствующего пациента надо изменить на одно окно вперёд.
Если существует несколько способов изменить записи требуемым образом, то выведите любой из них. Количество изменений записей минимизировать не требуется.
### Пример
**Входные данные**
```
4
5 5
2 1 3 5 2
5 4
1 1 1 1
200000 4
100000 100001 100001 100000
2 2
2 1
```
**Выходные данные**
```
 00+0+
x
-0+0
00
```  
</details>
<details>
<summary>H. Block Jigsaw Puzzle (30 баллов)</summary>
  
<h2><p align="center">H. Block Jigsaw Puzzle (30 баллов)</p></h2>
<p align="center"> ограничение по времени на тест: 10 секунд</p>
<p align="center"> ограничение по памяти на тест: 512 мегабайт</p>
<p align="center"> ввод: стандартный ввод</p>
<p align="center"> вывод: стандартный вывод</p>

  Слышали о Block Jigsaw Puzzle? Сейчас расскажем!

Игра происходит на поле 8×8. Каждая клетка поля либо свободна, либо занята блоком. Например, ниже на картинке изображено одно из возможных текущих состояний поля.
  ![image](https://user-images.githubusercontent.com/61276672/217305600-ab29a3b5-90a0-423d-8d89-2232b478716d.png)
Вам поступают фигуры, которые вы должны укладывать на поле. Вращать фигуры вы не можете. Когда вы кладёте фигуру на поле, все клетки, соответствующие этой фигуре, должны быть свободны. Вы можете выбрать любой из корректных способов положить фигуру.

Например, допустим, вы хотите положить следующую фигуру на поле:
  ![image](https://user-images.githubusercontent.com/61276672/217305732-a6e61a60-a593-43b3-8863-a9e4ed7b49be.png)
Есть всего один корректный способ положить её:
  ![image](https://user-images.githubusercontent.com/61276672/217305934-6dd896b4-bb39-4179-9fa3-d8c22ea172f3.png)
Как только фигура оказалась на поле, все полностью заполненные блоками строки и столбцы поля очищаются. Это действие происходит мгновенно, оставшиеся заполненные блоки остаются неподвижными.

В рассматриваемом примере очистятся одна строка и один столбец. После этого поле примет следующий вид:
  ![image](https://user-images.githubusercontent.com/61276672/217306054-f64b06b0-3738-4741-abd1-639100c3ca56.png)
Возможные фигуры для укладывания могут выглядеть следующим образом:
![image](https://user-images.githubusercontent.com/61276672/217306137-532f6caa-0e1e-4f66-bc02-c0e2b8f75d80.png)
Могут быть даны любые повороты и зеркальные отражения фигур с картинки выше. В процессе укладывания фигуры вращать её нельзя.

Вам задано текущее состояние поля и набор фигур для укладывания. Ваша цель — уложить фигуры так, чтобы минимизировать количество блоков на поле в конце игры. Фигуры можно укладывать в любом порядке. Обратите внимание, что каждый раз после размещения очередной фигуры на поле происходит очищение полностью заполненных блоками строк и столбцов.

Требуется последовательно уложить все фигуры и вывести минимальное количество блоков, которое останется на поле после укладывания всех фигур. Выведите -1, если уложить все фигуры невозможно.

Неполные решения этой задачи (например, недостаточно эффективные) могут быть оценены частичным баллом. Для набора 15 баллов достаточно решить частный случай задачи с k=1.
  
### Входные данные
Первые 8 строк содержат по 8 символов каждая — текущее состояние поля. Символ '.' (точка) соответствует пустой клетке, а символ '*' (звёздочка) — клетке с блоком. Гарантируется, что текущее состояние поля таково, что в нём нет сплошных строк и/или столбцов из блоков.

Следующая строка содержит целое число k (1≤k≤3) — количество заданных фигур. Обратите внимание, что первые тесты содержат только k=1, и для набора 15 баллов достаточно решить частный случай задачи с k=1.

Затем заданы фигуры. Описание каждой фигуры начинается со строки, которая содержит целое число li (1≤li≤5) — количество строк в описании фигуры. Затем заданы li строк с описанием фигуры в виде прямоугольника минимального размера, который её содержит. Формат задания аналогичен тому, как задано поле. Каждая фигура является одной из 12 допустимых (перечислены на картинке выше), возможно, повёрнутая и/или отражённая.
### Выходные данные
  Выведите одно целое число — минимальное количество блоков на поле после укладывания k заданных фигур в произвольном порядке оптимальным способом.

Выведите -1, если не существует способа уложить все фигуры на поле.

Заметим, что последний пример иллюстрирует случай k>1. Этот пример не обязательно должен проходить, чтобы вы набрали 15 баллов.
### Пример
**Входные данные**
```
*****.**
***.*.**
**..****
**..*...
........
****.***
...*.***
******..
1
3
***
..*
..*
```
**Выходные данные**
```
 29
```  
</details>
<details>
<summary>I. Отображение страниц (40 баллов)</summary>
  
<h2><p align="center">I. Отображение страниц (40 баллов)</p></h2>
<p align="center"> ограничение по времени на тест: 10 секунд</p>
<p align="center"> ограничение по памяти на тест: 512 мегабайт</p>
<p align="center"> ввод: стандартный ввод</p>
<p align="center"> вывод: стандартный вывод</p>

  В этой задаче вам предстоит написать отображение в текстовом виде простейших HTML-таблиц.

В задаче используется очень ограниченное подмножество HTML-разметки. Внимательно прочтите условие задачи.

В этой задаче все таблицы имеют строго прямоугольный вид, то есть содержат не менее одной строки, каждая строка содержит не менее одной ячейки, и во всех строках каждой отдельной таблицы одинаковое количество ячеек.

Таблица описывается следующей грамматикой:

* ⟨TABLE⟩ := <table>⟨ROWS⟩</table>
* ⟨ROWS⟩ := ⟨ROW⟩|⟨ROW⟩⟨ROWS⟩
* ⟨ROW⟩ := <tr>⟨CELLS⟩</tr>
* ⟨CELLS⟩ := ⟨CELL⟩|⟨CELL⟩⟨CELLS⟩
* ⟨CELL⟩ := <td></td>|<td>⟨TABLE⟩</td>
Таким образом, каждая ячейка таблицы либо пуста, либо содержит ровно одну другую таблицу.

Вот пример минимальной корректной таблицы: <table><tr><td></td></tr></table>.

Вот пример минимальной корректной таблицы размера 2×3: <table><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></table>.

Вот пример таблицы 2×1, в нижнюю клетку которой вложена минимальная таблица: <table><tr><td></td></tr><tr><td><table><tr><td></td></tr></table></td></tr></table>.

Ваша задача — отобразить заданную таблицу в текстовом виде. Каждая из таблиц (как внешняя, так и любая внутренняя) должна занимать минимальную площадь. Содержимое любой ячейки прижимается к её левому верхнему углу.

Изучите примеры и точно следуйте всем особенностям форматирования, которые продемонстрированы в них. В этой задаче вам нужно вывести в точности ожидаемое представление таблицы — не выводите лишние незначащие пробелы или какие-либо другие символы.
  
### Входные данные
В первой строке теста записано целое число t (1≤t≤100) — количество наборов входных данных в тесте.

Далее следуют описания наборов. Наборы входных данных в тесте независимы. Друг на друга они никак не влияют.

Каждый набор начинается строкой, которая содержит целое число k (1≤k≤1000) — количество строк, в которых записан очередной набор.

Далее следуют k строк, в которых записано описание ровно одной таблицы. Описание произвольным образом разбито на k строк и отформатировано пробелами, которые следует полностью игнорировать. Пробелы могут даже разрывать ключевые слова в HTML-разметке.

Каждая таблица (и внешняя, и все вложенные) соответствует грамматике выше и имеет строго прямоугольную форму: количества ячеек в каждой строке равны в рамках каждой отдельной таблицы.

Размер файла каждого теста не превосходит 1 мегабайта. Глубина вложенности таблиц не превосходит 10. Гарантируется, что размер вывода для любого теста не превосходит 1 мегабайта.
### Выходные данные
Выведите t заданных таблиц, следуя примерам. Каждая таблица должна занимать минимальную возможную площадь. Содержимое любой ячейки прижимается к её левому верхнему углу.

Точно следуйте примерам, они демонстрируют все особенности и требования форматирования вывода.

Гарантируется, что размер вывода для любого теста не превосходит 1 мегабайта.
### Пример
**Входные данные**
```
4
5
<table>
    <tr>
        <td></td>
    </tr>
</table>
4
<table>
    <tr><td></td><td></td><td></td></tr>
    <tr><td></td><td></td><td></td></tr>
</table>
5
<t                      a
ble><tr><td></td></tr><tr
><td><table><tr><td></td>
</tr></table></td></tr></
table                   >
35
<table>
    <tr>
        <td>
        </td>
        <td>
            <table>
                <tr><td>
                    <table><tr><td></td></tr></table>
                </td></tr>
            </table>
        </td>
        <td>
        </td>
    </tr>
    <tr>
        <td>
            <table><tr>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            </tr></table>
        </td>
        <td>
            <table><tr><td></td></tr></table>
        </td>
        <td>
            <table>
                <tr><td></td></tr>
                <tr><td></td></tr>
                <tr><td></td></tr>
            </table>
        </td>
    </tr>
</table>
```
**Выходные данные**
```
 +-+
|.|
+-+
+-+-+-+
|.|.|.|
+-+-+-+
|.|.|.|
+-+-+-+
+---+
|...|
+---+
|+-+|
||.||
|+-+|
+---+
+---------+-----+---+
|.........|+---+|...|
|.........||+-+||...|
|.........|||.|||...|
|.........||+-+||...|
|.........|+---+|...|
+---------+-----+---+
|+-+-+-+-+|+-+..|+-+|
||.|.|.|.|||.|..||.||
|+-+-+-+-+|+-+..|+-+|
|.........|.....||.||
|.........|.....|+-+|
|.........|.....||.||
|.........|.....|+-+|
+---------+-----+---+
```  
</details>
<details>
<summary>S1. Контест: простые задачи (SQL, 15 баллов)</summary>
  
<h2><p align="center">S1. Контест: простые задачи (SQL, 15 баллов)</p></h2>
<p align="center"> ограничение по времени на тест: 15 секунд</p>
<p align="center"> ограничение по памяти на тест: 1024 мегабайт</p>
<p align="center"> ввод: стандартный ввод</p>
<p align="center"> вывод: стандартный вывод</p>

  Это необычная задача — вам надо написать SQL-запрос. В качестве решения вы должны отослать один запрос к базе данных, который возвращает требуемые данные. Запрос может содержать произвольное количество подзапросов, других конструкций, быть сколь угодно навороченным, но это должен быть один запрос (в нём не должна встречаться точка с запятой для разделения разных запросов).

При проверке вашего решения используется PostgreSQL 15.1. В качестве входных данных вам предоставляется дамп состояния базы данных. Обратите внимание, что время работы вашего решения на тесте включает восстановление состояния базы данных из дампа, но это время значительно меньше ограничения по времени. Вы можете использовать сервис http://sqlfiddle.com/ как инструмент для запуска запросов.

В этой задаче вам предстоит написать запрос к базе данных простейшей системы проведения соревнований по программированию. Вы прямо сейчас участвуете в подобном соревновании. Время почувствовать себя в роли разработчика системы для проведения таких соревнований!

Напишите запрос к базе данных, который возвращает все задачи, которые были решены не менее чем двумя пользователями. Найденные задачи следует отсортировать по id.

Внимательно ознакомьтесь с примерами вывода. Ваш запрос должен иметь в точности такой же вывод на примерах.

Схема базы данных содержит четыре таблицы:

users — пользователи системы (описываются двумя полями: id и name),
contests — контесты в системе (описываются двумя полями: id и name),
problems — задачи в системе, каждая задача принадлежит одному контесту (описываются тремя полями: id, contest_id и code, где code — это кодовое короткое название задачи),
submissions — отосланные попытки решения задач, каждая попытка принадлежит одной задаче и одному пользователю (описываются 5 полями: id, user_id, problem_id, success и submitted_at, где success — это булевское значение была ли попытка успешной и submitted_at — дата-время, когда попытка была совершена).
Таким образом, contests и problems находятся в отношении «один ко многим», submissions и users находятся в отношении «многие к одному», submissions и problems находятся в отношении «многие к одному».

Изучите входные данные примера, чтобы подробно ознакомиться со схемой базы данных. Диаграмма ниже иллюстрирует схему базы данных.
  
  ![image](https://user-images.githubusercontent.com/61276672/217307251-b4d53d89-16ee-4591-b099-b1ea285a0391.png)

### Входные данные
Входными данными в этой задаче является дамп базы данных. Вам он может быть полезен для ознакомления с состоянием базы данных для конкретного теста. В качестве решения вы должны отправить один SQL-запрос.
### Выходные данные
  Ваш SQL-запрос должен вывести все подходящие задачи в порядке возрастания их id.

Внимательно ознакомьтесь с примерами вывода. Ваш запрос должен иметь в точности такой же вывод на примерах.
### Пример
**Входные данные**
```
create table users (
  id bigint primary key,
  name varchar not null
);

create table contests (
  id bigint primary key,
  name varchar not null
);

create table problems (
  id bigint primary key,
  contest_id bigint,
  code varchar not null,
  constraint fk_problems_contest_id foreign key (contest_id) references contests (id)
);

create unique index on problems (contest_id, code);

create table submissions (
  id bigint primary key,
  user_id bigint,
  problem_id bigint,
  success boolean not null,
  submitted_at timestamp not null,
  constraint fk_submissions_user_id foreign key (user_id) references users (id),
  constraint fk_submissions_problem_id foreign key (problem_id) references problems (id)
);

insert into users
values (1, 'Marie Curie'),
       (2, 'Stephen Hawking'),
       (3, 'Ada Lovelace'),
       (4, 'Albert Einstein'),
       (5, 'Archimedes');

insert into contests
values (1, 'Sandbox-Juniors'),
       (2, 'Sandbox-Seniors'),
       (3, 'Contest-Juniors'),
       (4, 'Contest-Seniors');

insert into problems
values (1, 1, 'A'),
       (2, 2, 'A'),
       (3, 3, 'A'),
       (4, 3, 'B'),
       (5, 4, 'A'),
       (6, 4, 'B');

insert into submissions
values (1, 2, 2, false, '2023-02-05 11:01:00'),
       (2, 2, 2, true, '2023-02-05 11:02:00'),
       (3, 2, 6, true, '2023-02-05 11:03:01'),
       (4, 2, 1, true, '2023-02-05 11:04:00'),
       (5, 2, 1, true, '2023-02-05 11:05:00'),
       (6, 3, 6, true, '2023-02-05 11:06:00'),
       (17, 1, 6, true, '2023-02-05 11:03:00'),
       (8, 1, 2, true, '2023-02-05 11:08:00'),
       (9, 1, 1, false, '2023-02-05 11:09:00'),
       (10, 3, 1, false, '2023-02-05 11:10:00'),
       (11, 5, 5, false, '2023-02-05 11:11:00'),
       (13, 2, 6, true, '2023-02-05 11:03:00'),
       (14, 3, 6, false, '2023-02-05 11:05:59'),
       (15, 1, 6, true, '2023-02-05 11:04:00');
```
**Выходные данные**
```
 id | contest_id | code
----+------------+------
  2 |          2 | A
  6 |          4 | B
(2 rows)
```  
</details>
<details>
<summary>S2. Контест: статистика пользователей (SQL, 15 баллов)</summary>
  
<h2><p align="center">S2. Контест: статистика пользователей (SQL, 15 баллов)</p></h2>
<p align="center"> ограничение по времени на тест: 15 секунд</p>
<p align="center"> ограничение по памяти на тест: 1024 мегабайт</p>
<p align="center"> ввод: стандартный ввод</p>
<p align="center"> вывод: стандартный вывод</p>

  Это необычная задача — вам надо написать SQL-запрос. В качестве решения вы должны отослать один запрос к базе данных, который возвращает требуемые данные. Запрос может содержать произвольное количество подзапросов, других конструкций, быть сколь угодно навороченным, но это должен быть один запрос (в нём не должна встречаться точка с запятой для разделения разных запросов).

При проверке вашего решения используется PostgreSQL 15.1. В качестве входных данных вам предоставляется дамп состояния базы данных. Обратите внимание, что время работы вашего решения на тесте включает восстановление состояния базы данных из дампа, но это время значительно меньше ограничения по времени. Вы можете использовать сервис http://sqlfiddle.com/ как инструмент для запуска запросов.

В этой задаче вам предстоит написать запрос к базе данных простейшей системы проведения соревнований по программированию. Вы прямо сейчас участвуете в подобном соревновании. Время почувствовать себя в роли разработчика системы для проведения таких соревнований!

Напишите запрос к базе данных, который возвращает всех пользователей вместе с некоторой дополнительной информацией:

количеством соревнований, в которых он принял участие и решил там хотя бы одну задачу, соответствующую колонку в выводе следует назвать solved_at_least_one_contest_count,
количеством соревнований, в которых он принял участие (то есть сделал хотя бы одну попытку решения), соответствующую колонку в выводе следует назвать take_part_contest_count.
Строки в выводе сортируйте в первую очередь по невозрастанию solved_at_least_one_contest_count, затем по невозрастанию take_part_contest_count, затем по возрастанию id.

Внимательно ознакомьтесь с примерами вывода. Ваш запрос должен иметь в точности такой же вывод на примерах.

Схема базы данных содержит четыре таблицы:

users — пользователи системы (описываются двумя полями: id и name),
contests — контесты в системе (описываются двумя полями: id и name),
problems — задачи в системе, каждая задача принадлежит одному контесту (описываются тремя полями: id, contest_id и code, где code — это кодовое короткое название задачи),
submissions — отосланные попытки решения задач, каждая попытка принадлежит одной задаче и одному пользователю (описываются 5 полями: id, user_id, problem_id, success и submitted_at, где success — это булевское значение была ли попытка успешной и submitted_at — дата-время, когда попытка была совершена).
Таким образом, contests и problems находятся в отношении «один ко многим», submissions и users находятся в отношении «многие к одному», submissions и problems находятся в отношении «многие к одному».

Изучите входные данные примера, чтобы подробно ознакомиться со схемой базы данных. Диаграмма ниже иллюстрирует схему базы данных.
  ![image](https://user-images.githubusercontent.com/61276672/217307566-5b8e04b8-89c1-4701-8b45-facf4913ca2c.png)

### Входные данные
Входными данными в этой задаче является дамп базы данных. Вам он может быть полезен для ознакомления с состоянием базы данных для конкретного теста. В качестве решения вы должны отправить один SQL-запрос.
### Выходные данные
  Ваш SQL-запрос должен вывести всех пользователей вместе с дополнительными колонками, как написано выше. В точности следуйте требованиям к именованию дополнительных колонок и порядку сортировки.

Внимательно ознакомьтесь с примерами вывода. Ваш запрос должен иметь в точности такой же вывод на примерах.
### Пример
**Входные данные**
```
create table users (
  id bigint primary key,
  name varchar not null
);

create table contests (
  id bigint primary key,
  name varchar not null
);

create table problems (
  id bigint primary key,
  contest_id bigint,
  code varchar not null,
  constraint fk_problems_contest_id foreign key (contest_id) references contests (id)
);

create unique index on problems (contest_id, code);

create table submissions (
  id bigint primary key,
  user_id bigint,
  problem_id bigint,
  success boolean not null,
  submitted_at timestamp not null,
  constraint fk_submissions_user_id foreign key (user_id) references users (id),
  constraint fk_submissions_problem_id foreign key (problem_id) references problems (id)
);

insert into users
values (1, 'Marie Curie'),
       (2, 'Stephen Hawking'),
       (3, 'Ada Lovelace'),
       (4, 'Albert Einstein'),
       (5, 'Archimedes');

insert into contests
values (1, 'Sandbox-Juniors'),
       (2, 'Sandbox-Seniors'),
       (3, 'Contest-Juniors'),
       (4, 'Contest-Seniors');

insert into problems
values (1, 1, 'A'),
       (2, 2, 'A'),
       (3, 3, 'A'),
       (4, 3, 'B'),
       (5, 4, 'A'),
       (6, 4, 'B');

insert into submissions
values (1, 2, 2, false, '2023-02-05 11:01:00'),
       (2, 2, 2, true, '2023-02-05 11:02:00'),
       (3, 2, 6, true, '2023-02-05 11:03:01'),
       (4, 2, 1, true, '2023-02-05 11:04:00'),
       (5, 2, 1, true, '2023-02-05 11:05:00'),
       (6, 3, 6, true, '2023-02-05 11:06:00'),
       (17, 1, 6, true, '2023-02-05 11:03:00'),
       (8, 1, 2, true, '2023-02-05 11:08:00'),
       (9, 1, 1, false, '2023-02-05 11:09:00'),
       (10, 3, 1, false, '2023-02-05 11:10:00'),
       (11, 5, 5, false, '2023-02-05 11:11:00'),
       (13, 2, 6, true, '2023-02-05 11:03:00'),
       (14, 3, 6, false, '2023-02-05 11:05:59'),
       (15, 1, 6, true, '2023-02-05 11:04:00');
```
**Выходные данные**
```
  id |      name       | solved_at_least_one_contest_count | take_part_contest_count
----+-----------------+-----------------------------------+-------------------------
  2 | Stephen Hawking |                                 3 |                       3
  1 | Marie Curie     |                                 2 |                       3
  3 | Ada Lovelace    |                                 1 |                       2
  5 | Archimedes      |                                 0 |                       1
  4 | Albert Einstein |                                 0 |                       0
(5 rows)
```  
</details>
<details>
<summary>S3. Контест: таблица результатов (SQL, 30 баллов)</summary>
  
<h2><p align="center">S3. Контест: таблица результатов (SQL, 30 баллов)</p></h2>
<p align="center"> ограничение по времени на тест: 15 секунд</p>
<p align="center"> ограничение по памяти на тест: 1024 мегабайта</p>
<p align="center"> ввод: стандартный ввод</p>
<p align="center"> вывод: стандартный вывод</p>
Это необычная задача — вам надо написать SQL-запрос. В качестве решения вы должны отослать один запрос к базе данных, который возвращает требуемые данные. Запрос может содержать произвольное количество подзапросов, других конструкций, быть сколь угодно навороченным, но это должен быть один запрос (в нём не должна встречаться точка с запятой для разделения разных запросов).

При проверке вашего решения используется PostgreSQL 15.1. В качестве входных данных вам предоставляется дамп состояния базы данных. Обратите внимание, что время работы вашего решения на тесте включает восстановление состояния базы данных из дампа, но это время значительно меньше ограничения по времени. Вы можете использовать сервис http://sqlfiddle.com/ как инструмент для запуска запросов.

В этой задаче вам предстоит написать запрос к базе данных простейшей системы проведения соревнований по программированию. Вы прямо сейчас участвуете в подобном соревновании. Время почувствовать себя в роли разработчика системы для проведения таких соревнований!

Напишите запрос к базе данных, который построит таблицу результатов для соревнования с максимальным id.

Вывод должен включать всех пользователей, кто сделал хотя бы одну попытку в этом соревновании. Вывод должен включать 5 колонок:

rank — место пользователя в контесте (пользователи с одинаковыми результатами делят место);
user_id — id пользователя;
user_name — name пользователя;
problem_count — количество решённых в контесте задач (если одна задача решена многократно, то всё-равно учитывается как одна задача);
latest_successful_submitted_at — время, когда была решена последняя из решённых задач у этого пользователя (если одна задача решена многократно, то задача считается решённой в момент первого решения), иными словами, последний момент времени, когда у пользователя увеличилось количество решённых задач.
Строки следует сортировать по невозрастанию problem_count, затем по неубыванию latest_successful_submitted_at, затем по возрастанию user_id.

Пользователи, которые решили одинаковое количество задач (имеют равные problem_count) и имеют равные значения latest_successful_submitted_at, должны поделить одно место. Обратите внимание, что если несколько пользователей делят места, то в нумерации мест образуется разрыв. Например, если первое место делят два пользователя, то следующий пользователь должен получить место 3 (то есть последовательность мест имеет вид: 1,1,3).

Внимательно ознакомьтесь с примерами вывода. Ваш запрос должен иметь в точности такой же вывод на примерах.

users — пользователи системы (описываются двумя полями: id и name),
contests — контесты в системе (описываются двумя полями: id и name),
problems — задачи в системе, каждая задача принадлежит одному контесту (описываются тремя полями: id, contest_id и code, где code — это кодовое короткое название задачи),
submissions — отосланные попытки решения задач, каждая попытка принадлежит одной задаче и одному пользователю (описываются 5 полями: id, user_id, problem_id, success и submitted_at, где success — это булевское значение была ли попытка успешной и submitted_at — дата-время, когда попытка была совершена).
Таким образом, contests и problems находятся в отношении «один ко многим», submissions и users находятся в отношении «многие к одному», submissions и problems находятся в отношении «многие к одному».

Изучите входные данные примера, чтобы подробно ознакомиться со схемой базы данных. Диаграмма ниже иллюстрирует схему базы данных.
  
  ![image](https://user-images.githubusercontent.com/61276672/217313960-f54816b8-dce3-485e-81ce-86cb9a86b18d.png)


  
### Входные данные
Входными данными в этой задаче является дамп базы данных. Вам он может быть полезен для ознакомления с состоянием базы данных для конкретного теста. В качестве решения вы должны отправить один SQL-запрос.
  
### Выходные данные
 Ваш SQL-запрос должен вывести результаты соревнования с максимальным id в требуемом формате.

Внимательно ознакомьтесь с примерами вывода. Ваш запрос должен иметь в точности такой же вывод на примерах.
  
### Пример
**Входные данные**
```
create table users (
  id bigint primary key,
  name varchar not null
);

create table contests (
  id bigint primary key,
  name varchar not null
);

create table problems (
  id bigint primary key,
  contest_id bigint,
  code varchar not null,
  constraint fk_problems_contest_id foreign key (contest_id) references contests (id)
);

create unique index on problems (contest_id, code);

create table submissions (
  id bigint primary key,
  user_id bigint,
  problem_id bigint,
  success boolean not null,
  submitted_at timestamp not null,
  constraint fk_submissions_user_id foreign key (user_id) references users (id),
  constraint fk_submissions_problem_id foreign key (problem_id) references problems (id)
);

insert into users
values (1, 'Marie Curie'),
       (2, 'Stephen Hawking'),
       (3, 'Ada Lovelace'),
       (4, 'Albert Einstein'),
       (5, 'Archimedes');

insert into contests
values (1, 'Sandbox-Juniors'),
       (2, 'Sandbox-Seniors'),
       (3, 'Contest-Juniors'),
       (4, 'Contest-Seniors');

insert into problems
values (1, 1, 'A'),
       (2, 2, 'A'),
       (3, 3, 'A'),
       (4, 3, 'B'),
       (5, 4, 'A'),
       (6, 4, 'B');

insert into submissions
values (1, 2, 2, false, '2023-02-05 11:01:00'),
       (2, 2, 2, true, '2023-02-05 11:02:00'),
       (3, 2, 6, true, '2023-02-05 11:03:01'),
       (4, 2, 1, true, '2023-02-05 11:04:00'),
       (5, 2, 1, true, '2023-02-05 11:05:00'),
       (6, 3, 6, true, '2023-02-05 11:06:00'),
       (17, 1, 6, true, '2023-02-05 11:03:00'),
       (8, 1, 2, true, '2023-02-05 11:08:00'),
       (9, 1, 1, false, '2023-02-05 11:09:00'),
       (10, 3, 1, false, '2023-02-05 11:10:00'),
       (11, 5, 5, false, '2023-02-05 11:11:00'),
       (13, 2, 6, true, '2023-02-05 11:03:00'),
       (14, 3, 6, false, '2023-02-05 11:05:59'),
       (15, 1, 6, true, '2023-02-05 11:04:00');
```
**Выходные данные**
```
 rank | user_id |    user_name    | problem_count | latest_successful_submitted_at
------+---------+-----------------+---------------+--------------------------------
    1 |       1 | Marie Curie     |             1 | 2023-02-05 11:03:00
    1 |       2 | Stephen Hawking |             1 | 2023-02-05 11:03:00
    3 |       3 | Ada Lovelace    |             1 | 2023-02-05 11:06:00
    4 |       5 | Archimedes      |             0 |
(4 rows)
```  
</details>
